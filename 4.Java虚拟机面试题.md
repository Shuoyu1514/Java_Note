##   Java虚拟机面试题

##  内存模型

### JVM的内存模型介绍一下

根据 JDK 8 规范，JVM 运行时内存共分为==虚拟机栈、堆、元空间、程序计数器、本地方法栈==五个部分。还有一部分内存叫直接内存，属于操作系统的本地内存，也是可以直接操作的。

![image-20250405145831101](./4.Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20250405145831101.png)
<u>虚拟机栈，本地方法栈，程序计数器是线程私有，堆和元空间是多个线程共享</u>

JVM的内存结构主要分为以下几个部分：

+   **程序计数器**：可以看作是当前线程所执行的字节码的行号指示器，用于存储当前线程正在执行的 Java 方法的 ==JVM 指令地址==。如果线程执行的是 Native 方法，计数器值为 null。<u>==是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域==</u>，生命周期与线程相同。
+   **Java 虚拟机栈**：==**每个线程**都有自己独立的 Java 虚拟机栈，生命周期与线程相同。每个方法在执行时都会创建一个**栈帧**==，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。可能会抛出 StackOverflowError 和 OutOfMemoryError 异常。

> HotSpot虚拟机的栈容量是不可以动态扩展的，所以在HotSpot虚拟机上是不会由于虚拟机栈无法扩展而导致Out Of Memory Error异常

+   **本地方法栈**：与 Java 虚拟机栈类似，主要为虚拟机使用到的 ==Native 方法==服务，在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。本地方法执行时也会创建栈帧，同样可能出现 StackOverflowError 和 OutOfMemoryError 两种错误。
+   **Java 堆**：是 JVM 中最大的一块内存区域，被所有线程共享，在虚拟机启动时创建，用于存放对象实例。从内存回收角度，堆被划分为==新生代和老年代==，新生代又分为 Eden 区和两个 Survivor 区（==From Survivor 和 To Survivor==）。如果在堆中没有内存完成实例分配，并且堆也无法扩展时会抛出 OutOfMemoryError 异常。

> Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被认为是连续的

+   **方法区（元空间）**：在 JDK 1.8 及以后的版本中，方法区被元空间取代，使用本地内存。用于==存储已被虚拟机加载的类信息、常量、静态变量等数据==。虽然方法区被描述为堆的逻辑部分，但有 “非堆” 的别名。方法区可以选择不实现垃圾收集，内存不足时会抛出 OutOfMemoryError 异常。
    +   **运行时常量池**：是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，具有动态性，运行时也可将新的常量放入池中。当无法申请到足够内存时，会抛出 OutOfMemoryError 异常。
    +   **直接内存**：不属于 JVM 运行时数据区的一部分，通过 NIO 类引入，是一种堆外内存，可以显著提高 I/O 性能。直接内存的使用受到本机总内存的限制，若分配不当，可能导致 OutOfMemoryError 异常。

> **字符串常量池**单独存放，JDK1.8之后在Java**堆**内存中，更易于管理。
>
> 调用intern()的字符串会确保从字符串常量池中返回唯一引用。
>
> • 若堆中已存在该字符串（new String()创建的），则直接将堆中字符串引用加入字符串常量池，不再创建新对象。
>
> • 若不存在，则在堆中创建并加入常量池。
>
> ```java
> String s1 = new String("abc"); 会创建两个对象，一个在常量池中一个在堆中
> ```
>
> 
>
> ```java
> // s1 指向字符串常量池中的 "Java" 对象
> String s1 = "Java";
> // s2 也指向字符串常量池中的 "Java" 对象，和 s1 是同一个对象
> String s2 = s1.intern();
> // 在堆中创建一个新的 "Java" 对象，s3 指向它
> String s3 = new String("Java");
> // s4 指向字符串常量池中的 "Java" 对象，和 s1 是同一个对象
> String s4 = s3.intern();
> // s1 和 s2 指向的是同一个常量池中的对象
> System.out.println(s1 == s2); // true
> // s3 指向堆中的对象，s4 指向常量池中的对象，所以不同
> System.out.println(s3 == s4); // false
> // s1 和 s4 都指向常量池中的同一个对象
> System.out.println(s1 == s4); // true
> ```
>

> - **成员变量**：属于对象的一部分，存储在对象内，而对象默认是在堆中分配的（除非被逃逸优化到栈上）。
> - **静态成员**变量会存储在方法区/元空间

#### 栈

栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址

- 局部变量：在方法中定义的变量（基本类型和引用类型的变量）存储在栈中。
- 操作数栈：主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。
- 动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 动态连接 

可能会出现两种错误：

- StackOverFlowError：栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候
- OutOfMemoryError：如果栈的内存大小可以动态扩展， 那么当虚拟机在动态扩展栈时无法申请到足够的内存空间

#### 本地方法栈

虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务

#### 堆

唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存

> JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么==对象可以直接在栈上分配内存==。

<u>在 JDK 7 版本及 JDK 7 版本之前</u>，堆内存被通常分为下面三部分：

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永久代(Permanent Generation)

<u>JDK 8 版本</u>之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存

![image-20250406131454040](./4.Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20250406131454040.png)

在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中

> 年龄只能是 0-15
>
> - 因为记录年龄的区域在对象头中，这个区域的大小通常是 4 位。这 4 位可以表示的最大二进制数字是 1111，即十进制的 15
>
> ==但并不是只有年龄到15才会进入老年代==
>
> - HotSpot 会在每次 Young GC 后，动态计算一个新的晋升阈值。
> - 遍历 Survivor 区所有对象，按年龄分组（如年龄 1、年龄 2……年龄 N），并计算每组对象占用的总内存大小。
> - 从年龄最小的对象（年龄 1）开始，逐步累加各年龄组的内存占用，直到满足以下条件：
>   累加的总大小 > Survivor 区容量的一半
> - 最终阈值取 `min(X, MaxTenuringThreshold)`
> - 年龄大于或等于该年龄的对象就可以直接进入老年代
>
> 另外 ==CMS 的默认值是 6==
>
> 为什么？
>
> 1. 如果固定按照MaxTenuringThreshold设定的阈值作为晋升条件： 
>    - a）MaxTenuringThreshold设置的过大，原本应该晋升的对象一直停留在Survivor区，直到Survivor区溢出，一旦溢出发生，Eden+Svuvivor中对象将不再依据年龄全部提升到老年代，这样==对象老化的机制就失效了==。 
>    - b）MaxTenuringThreshold设置的过小，“==过早晋升==”即对象不能在新生代充分被回收，大量短期对象被晋升到老年代，老年代空间迅速增长，引起频繁的Major GC。分代回收失去了意义，严重影响GC性能。
> 2. 相同应用在不同时间的表现不同：特殊任务的执行或者流量成分的变化，都会导致对象的生命周期分布发生波动，那么固定的阈值设定，因为无法动态适应变化，会造成和上面相同的问题。

堆这里最容易出现的就是 `OutOfMemoryError` 错误

##### 堆大小上限？

32 位 JVM：由于地址空间只有 4GB（2^32）可用，因此<u>理论上堆最大只能到 4GB</u>。

==32 位系统上 -Xmx 设置大概在 1.5GB ~ 2GB 就会开始出现问题==



#### 方法区

方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据

![image-20250406132219366](./4.Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20250406132219366.png)

元空间常用参数：

```java
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```



#### 运行时常量池

常量池是==方法区==的一部分

运行时常量池是类被加载到JVM时类常量池的内存版本：当Java类被加载到JVM时，各个类文件中的类常量池内容被读取并存入到运行时常量池中，其中字符串的部分直接进到字符串池，其他常量进入到运行时常量池。

#### 字符串常量池

字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。保存在==堆==中

#### 直接内存

通过 JNI 的方式在本地内存上分配的。

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 `OutOfMemoryError` 错误出现。

JDK1.4 中新加入的 NIO（Non-Blocking I/O，也被称为 New I/O），引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作

> 堆外内存：把内存对象分配在堆外的内存，这些内存直接受操作系统管理



### 新生代和老年代分配大小？为什么这样分配？

新生代1/3: 存放新创建的对象，生命周期短，GC 频繁

老年代2/3: 存放长期存活的对象，GC 较少

- Eden（80%）：新对象首先分配在 Eden 区。
- Survivor 0（10%）：存放 Minor GC 后存活的对象（From 区）。
- Survivor 1（10%）：空的 Survivor 区（To 区），用于复制存活对象。

### * jvm 有什么指令设置内存

基础堆内存设置：

```shell
-Xms512m  // 设置初始堆大小为512MB
-Xmx2048m // 设置最大堆大小为2GB

-Xmn256m  // 设置新生代为256MB
-XX:NewRatio=2  // 老年代是新生代的2倍
-XX:SurvivorRatio=8  // Eden区是一个Survivor区的8倍
```

非堆内存设置：

```shell
-XX:MetaspaceSize=128m //初始元空间大小
-XX:MaxMetaspaceSize=512m //最大元空间大小
-XX:MaxDirectMemorySize=256m //最大直接内存大小
-Xss1m //每个线程的栈大小为1MB
```

垃圾回收相关:

```shell
-XX:+UseG1GC //启用G1垃圾收集器
-XX:MaxGCPauseMillis=200 //目标最大GC停顿时间
```

> `-Xms`和`-Xmx`通常设置为相同值，避免堆内存动态调整带来的性能开销

###  JVM内存模型里的堆和栈有什么区别？

+   **用途**：栈主要用于==存储局部变量、方法调用的参数、方法返回地址以及一些临时数据==。每当一个方法被调用，一个栈帧（stack frame）就会在栈中创建，用于存储该方法的信息，当方法执行完毕，栈帧也会被移除。堆用于存储对象的实例（包括==类的实例和数组==）。当你使用`new`关键字创建一个对象时，对象的实例就会在堆上分配空间。
+   **生命周期**：栈中的数据具有确定的生命周期，当一个==方法调用==结束时，其对应的栈帧就会被销毁，栈中存储的局部变量也会随之消失。堆中的对象生命周期不确定，对象会在垃圾回收机制（Garbage Collection, GC）检测到对象不再被引用时才被回收。
+   **存取速度**：栈的存取速度通常比堆快，因为栈遵循先进后出（LIFO, Last In First Out）的原则，操作简单快速。堆的存取速度相对较慢，因为对象在堆上的分配和回收需要更多的时间，而且垃圾回收机制的运行也会影响性能。
+   **存储空间**：==栈的空间相对较小==，且固定，由操作系统管理。当栈溢出时，通常是因为递归过深或局部变量过大。==堆的空间较大==，动态扩展，由JVM管理。堆溢出通常是由于==创建了太多的大对象或未能及时回收不再使用的对象==。
+   **可见性**：栈中的数据对线程是私有的，每个线程有自己的栈空间。堆中的数据对线程是共享的，所有线程都可以访问堆上的对象。

###  栈中存的到底是指针还是对象？

在JVM内存模型中，栈（Stack）主要用于管理线程的局部变量和方法调用的上下文，而堆（Heap）则是用于存储所有类的实例和数组。

当我们在栈中讨论“存储”时，实际上指的是存储基本类型的数据（如int, double等）和对象的引用，而不是对象本身。

这里的关键点是，栈中存储的**不是**对象，而是**对象的引用**。也就是说，当你在方法中声明一个对象，比如`MyObject obj = new MyObject();`，这里的`obj`实际上是一个存储在栈上的引用，指向堆中实际的对象实例。这个引用是一个固定大小的数据（例如在64位系统上是8字节），它指向堆中分配给对象的内存区域。

### 堆分为哪几部分呢？

Java堆（Heap）是Java虚拟机（JVM）中内存管理的一个重要区域，主要用于存放对象实例和数组。随着JVM的发展和不同垃圾收集器的实现，堆的具体划分可能会有所不同，但通常可以分为以下几个部分：

![img](https://cdn.xiaolincoding.com//picgo/1719974471041-14f6ed7f-358b-426a-b614-2501ceae0035.png)

+   **新生代（Young Generation）**:新生代分为==Eden Space和Survivor Space==。在Eden Space中， 大多数新创建的对象首先存放在这里。Eden区相对较小，当Eden区满时，会触发一次Minor GC（新生代垃圾回收）。在Survivor Spaces中，通常分为两个相等大小的区域，称为S0（Survivor 0）和S1（Survivor 1）。在每次Minor GC后，存活下来的对象会被移动到其中一个Survivor空间，以继续它们的生命周期。这两个区域轮流充当对象的中转站，帮助区分短暂存活的对象和长期存活的对象。
+   **老年代（Old Generation/Tenured Generation）**:==存放过一次或多次Minor GC仍存活的对象会被移动到老年代==。老年代中的对象生命周期较长，因此Major GC（也称为Full GC，涉及老年代的垃圾回收）发生的频率相对较低，但其执行时间通常比Minor GC长。老年代的空间通常比新生代大，以存储更多的长期存活对象。
+   **元空间（Metaspace）**:从Java 8开始，永久代（Permanent Generation）被元空间取代，用于存储类的元数据信息，如类的结构信息（如字段、方法信息等）。元空间并不在Java堆中，而是使用本地内存，这解决了永久代容易出现的内存溢出问题。
+   **大对象区（Large Object Space / Humongous Objects）**:在某些JVM实现中（如G1垃圾收集器），为大对象分配了专门的区域，称为大对象区或Humongous Objects区域。大对象是指需要大量连续内存空间的对象，如大数组。这类对象直接分配在老年代，以避免因频繁的年轻代晋升而导致的内存碎片化问题。

###  如果有个大对象一般是在哪个区域？

大对象通常会直接分配到老年代。

新生代主要用于存放生命周期较短的对象，并且其内存空间相对较小。如果将大对象分配到新生代，可能会很快导致新生代空间不足，从而频繁触发 Minor GC。而每次 Minor GC 都需要进行对象的复制和移动操作，这会带来一定的性能开销。将大对象直接分配到老年代，可以减少新生代的内存压力，降低 Minor GC 的频率。

大对象通常需要连续的内存空间，如果在新生代中频繁分配和回收大对象，容易产生内存碎片，导致后续分配大对象时可能因为内存不连续而失败。老年代的空间相对较大，更适合存储大对象，有助于减少内存碎片的产生。

###  程序计数器的作用，为什么是私有的？

Java程序是支持多线程一起运行的，多个线程一起运行的时候cpu会有一个调动器组件给它们分配时间片，比如说会给线程1分给一个时间片，它在时间片内如果它的代码没有执行完，它就会把线程1的状态执行一个暂存，切换到线程2去，执行线程2的代码，等线程2的代码执行到了一定程度，线程2的时间片用完了，再切换回来，再继续执行线程1剩余部分的代码。

我们考虑一下，如果在线程切换的过程中，下一条指令执行到哪里了，是不是还是会用到我们的程序计数器啊。每个线程都有自己的程序计数器，因为它们各自执行的代码的指令地址是不一样的呀，所以每个线程都应该有自己的程序计数器。

###  方法区中的方法的执行过程？

当程序中通过对象或类直接调用某个方法时，主要包括以下几个步骤：

+   **解析方法调用**：JVM会根据方法的符号引用找到实际的方法地址（如果之前没有解析过的话）。
+   **栈帧创建**：在调用一个方法前，JVM会在当前线程的Java虚拟机栈中为该方法分配一个新的栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
+   **执行方法**：执行方法内的字节码指令，涉及的操作可能包括局部变量的读写、操作数栈的操作、跳转控制、对象创建、方法调用等。
+   **返回处理**：方法执行完毕后，可能会返回一个结果给调用者，并清理当前栈帧，恢复调用者的执行环境。

###  方法区中还有哪些东西？

《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的**类型信息、常量、静态变量、即时编译器编译后的代码缓存**等。

+   类信息：包括类的结构信息、类的访问修饰符、父类与接口等信息。
+   常量池：存储类和接口中的常量，包括字面值常量、符号引用，以及运行时常量池。
+   静态变量：存储类的静态变量，这些变量在类初始化的时候被赋值。
+   方法字节码：存储类的方法字节码，即编译后的代码。
+   符号引用：存储类和方法的符号引用，是一种直接引用不同于直接引用的引用类型。
+   运行时常量池：存储着在类文件中的常量池数据，在类加载后在方法区生成该运行时常量池。
+   常量池缓存：用于提升类加载的效率，将常用的常量缓存起来方便使用。

###  String保存在哪里呢？

String 保存在字符串常量池中，不同于其他对象，它的值是不可变的，且可以被多个引用共享。

###  String s = new String（“abc”）执行过程中分别对应哪些内存区域？

首先，我们看到这个代码中有一个new关键字，我们知道**new**指令是创建一个类的实例对象并完成加载初始化的，因此这个字符串对象是在**运行期**才能确定的，创建的字符串对象是在**堆内存上**。

其次，在String的构造方法中传递了一个字符串abc，由于这里的abc是被final修饰的属性，所以它是一个字符串常量。在首次构建这个对象时，JVM拿字面量"abc"去字符串常量池试图获取其对应String对象的引用。于是在堆中创建了一个"abc"的String对象，并将其引用保存到字符串常量池中，然后返回；

所以，**如果abc这个字符串常量不存在，则创建两个对象，==分别是abc这个字符串常量，以及new String这个实例对象==。如果abc这字符串常量存在，则只会创建一个对象**。

###  *** 引用类型有哪些？有什么区别？**

引用类型主要分为强软弱虚四种：

+   ==强引用==是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object0”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
+   ==软引用==是用来描述一些还有用，但非必须的对象。<u>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存</u>。在JDK 1.2版之后提供了SoftReference类来实现软引用。
+   ==弱引用==也是用来描述那些非必须对象。当<u>垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</u>。在JDK 1.2版之后提供了WeakReference类来实现弱引用。**ThreadlocalMap**
+   ==虚引用==也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。

> 在程序设计中一般很少使用弱引用与虚引用，==使用软引用的情况较多==，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生

###  *** 弱引用了解吗?举例说明在哪里可以用?**

Java中的弱引用是一种引用类型，它不会阻止一个对象被垃圾回收。

在Java中，弱引用是通过`Java.lang.ref.WeakReference`类实现的。弱引用的一个主要用途是创建非强制性的对象引用，这些引用可以在内存压力大时被垃圾回收器清理，从而避免内存泄露。

弱引用的使用场景：

+   **缓存系统**：弱引用常用于实现缓存，特别是当希望缓存项能够在内存压力下自动释放时。如果缓存的大小不受控制，可能会导致内存溢出。使用弱引用来维护缓存，可以让JVM在需要更多内存时自动清理这些缓存对象。
+   **对象池**：在对象池中，弱引用可以用来管理那些暂时不使用的对象。当对象不再被强引用时，它们可以被垃圾回收，释放内存。
+   **避免内存泄露**：当一个对象不应该被长期引用时，使用弱引用可以防止该对象被意外地保留，从而避免潜在的内存泄露。
+   **ThreadLocal**：每个条目的 key 是对 ThreadLocal 对象的弱引用；与之对应的 value 却是强引用，如果不及时清理，可能会导致内存泄漏问题

示例代码：

假设我们有一个缓存系统，我们使用弱引用来维护缓存中的对象：

```java
import Java.lang.ref.WeakReference;
import Java.util.HashMap;
import Java.util.Map;

public class CacheExample {

    private Map<String, WeakReference<MyHeavyObject>> cache = new HashMap<>();

    public MyHeavyObject get(String key) {
        WeakReference<MyHeavyObject> ref = cache.get(key);
        if (ref != null) {
            return ref.get();
        } else {
            MyHeavyObject obj = new MyHeavyObject();
            cache.put(key, new WeakReference<>(obj));
            return obj;
        }
    }

    // 假设MyHeavyObject是一个占用大量内存的对象
    private static class MyHeavyObject {
        private byte[] largeData = new byte[1024 * 1024 * 10]; // 10MB data
    }
}
```

在这个例子中，使用`WeakReference`来存储`MyHeavyObject`实例，当内存压力增大时，垃圾回收器可以自由地回收这些对象，而不会影响缓存的正常运行。

如果一个对象被垃圾回收，下次尝试从缓存中获取时，`get()`方法会返回`null`，这时我们可以重新创建对象并将其放入缓存中。因此，使用弱引用时要注意，一旦对象被垃圾回收，通过弱引用获取的对象可能会变为`null`，因此在使用前通常需要检查这一点。

###  *** 内存泄漏和内存溢出的理解？**

**内存泄露**：内存泄漏是指==程序在运行过程中不再使用的对象仍然被引用，而无法被垃圾收集器回收，从而导致可用内存逐渐减少==。虽然在Java中，垃圾回收机制会自动回收不再使用的对象，但如果有对象仍被不再使用的引用持有，垃圾收集器无法回收这些内存，最终可能导致程序的内存使用不断增加。

内存泄露常见原因：

+   **静态集合**：使用静态数据结构（如`HashMap`或`ArrayList`）存储对象，且未清理。
+   **事件监听**：未取消对事件源的监听，导致对象持续被引用。
+   **线程**：未停止的线程可能持有对象引用，无法被回收。

内存溢出：内存溢出是指Java虚拟机（JVM）在申请内存时，无法找到足够的内存，最终引发`OutOfMemoryError`。这通常发生在堆内存不足以存放新创建的对象时。

内存溢出常见原因：

+   **大量对象创建**：程序中不断创建大量对象，超出JVM堆的限制。
+   **持久引用**：大型数据结构（如缓存、集合等）长时间持有对象引用，导致内存累积。
+   **递归调用**：深度递归导致栈溢出。

###  jvm 内存结构有哪几种内存溢出的情况？

+   **堆内存溢出**：当出现Java.lang.OutOfMemoryError:Java heap space异常时，就是堆内存溢出了。原因是代码中可能存在大对象分配，或者发生了内存泄露，导致在多次GC之后，还是无法找到一块足够大的内存容纳当前对象。
+   **栈溢出**：如果我们写一段程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。类似这种情况，JVM 实际会抛出 StackOverFlowError；当然，如果 JVM 试图去扩展栈空间的的时候失败，则会抛出 OutOfMemoryError。
+   **元空间溢出**：元空间的溢出，系统会抛出Java.lang.OutOfMemoryError: Metaspace。出现这个异常的问题的原因是系统的代码非常多或引用的第三方包非常多或者通过动态代码生成类加载等方法，导致元空间的内存占用很大。
+   **直接内存内存溢出**：在使用ByteBuffer中的allocateDirect()的时候会用到，很多JavaNIO(像netty)的框架中被封装为其他的方法，出现该问题时会抛出Java.lang.OutOfMemoryError: Direct buffer memory异常。

###  * 有具体的内存泄漏和内存溢出的例子么请举例及解决方案?

> 1、静态属性导致内存泄露

会导致内存泄露的一种情况就是大量使用static静态变量。在Java中，静态属性的生命周期通常伴随着应用整个生命周期（除非ClassLoader符合垃圾回收的条件）。下面来看一个具体的会导致内存泄露的实例：

```java
public class StaticTest {
    public static List<Double> list = new ArrayList<>();
    public void populateList() {
        for (int i = 0; i < 10000000; i++) {
            list.add(Math.random());
        }
        Log.info("Debug Point 2");
    }
    public static void main(String[] args) {
        Log.info("Debug Point 1");
        new StaticTest().populateList();
        Log.info("Debug Point 3");
    }
}
```

如果监控内存堆内存的变化，会发现在打印Point1和Point2之间，堆内存会有一个明显的增长趋势图。但当执行完populateList方法之后，对堆内存并没有被垃圾回收器进行回收。

![image-20240820112907539](https://cdn.xiaolincoding.com//picgo/image-20240820112907539.png)

但针对上述程序，如果将定义list的变量前的static关键字去掉，再次执行程序，会发现内存发生了具体的变化。VisualVM监控信息如下图：

![image-20240820112851893](https://cdn.xiaolincoding.com//picgo/image-20240820112851893.png)

对比两个图可以看出，程序执行的前半部分内存使用情况都一样，但当执行完populateList方法之后，后者不再有引用指向对应的数据，垃圾回收器便进行了回收操作。因此，我们要十分留意static的变量，如果集合或大量的对象定义为static的，它们会停留在整个应用程序的生命周期当中。而它们所占用的内存空间，本可以用于其他地方。

那么如何优化呢？第一，进来减少静态变量；第二，如果使用单例，尽量采用懒加载。

> 2、 未关闭的资源

无论什么时候当我们创建一个连接或打开一个流，JVM都会分配内存给这些资源。比如，数据库链接、输入流和session对象。

忘记关闭这些资源，会阻塞内存，从而导致GC无法进行清理。特别是当程序发生异常时，没有在finally中进行资源关闭的情况。这些未正常关闭的连接，如果不进行处理，轻则影响程序性能，重则导致OutOfMemoryError异常发生。

如果进行处理呢？第一，始终记得在finally中进行资源的关闭；第二，关闭连接的自身代码不能发生异常；第三，Java7以上版本可使用try-with-resources代码方式进行资源关闭。

> 3、 使用ThreadLocal

ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定，从而实现线程安全的特性。

![image-20240820112835783](https://cdn.xiaolincoding.com//picgo/image-20240820112835783.png)

ThreadLocal的实现中，每个Thread维护一个ThreadLocalMap映射表，key是ThreadLocal实例本身，value是真正需要存储的Object。

ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统GC时，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value。

如果当前线程迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value永远无法回收，造成内存泄漏。

如何解决此问题？

+   第一，使用ThreadLocal提供的remove方法，可对当前线程中的value值进行移除；
+   第二，不要使用ThreadLocal.set(null) 的方式清除value，它实际上并没有清除值，而是查找与当前线程关联的Map并将键值对分别设置为当前线程和null。
+   第三，最好将ThreadLocal视为需要在finally块中关闭的资源，以确保即使在发生异常的情况下也始终关闭该资源。

```java
try {
    threadLocal.set(System.nanoTime());
    //... further processing
} finally {
    threadLocal.remove();
}
```

##  类初始化和类加载

### *** 对象的内存布局**

在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：==对象头（Header）、实例数据 （Instance Data）和对齐填充（Padding）==。

#### 对象头

HotSpot虚拟机对象的对象头部分包括两类信息。

- ==标记字段==（Mark Word）：用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。
- ==类型指针==（Klass pointer）：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

> 查找对象的元数据信息并不一定要经过对象本身，
>
> 如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据

实例数据：对象真正存储的有效信息

对齐填充：没有实际意义，不是必要存在，起占位作用

### **对象的访问定位**

句柄/直接指针

#### 句柄

Java ==堆中将会划分出一块内存来作为句柄池==，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息

使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 <u>reference 本身不需要修改</u>。

![image-20250401204122405](./4.Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20250401204122405.png)

#### 直接指针

如果使用直接指针访问，reference 中存储的直接就是对象的地址。

使用直接指针访问方式最大的好处就是<u>速度快</u>，它节省了一次指针定位的时间开销。

<img src="./4.Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20250401204129521.png" alt="image-20250401204129521" style="zoom:50%;" />

###  对象的生命周期

对象的生命周期包括创建、使用和销毁三个阶段：

+   创建：对象通过关键字new在堆内存中被实例化，构造函数被调用，对象的内存空间被分配。
+   使用：对象被引用并执行相应的操作，可以通过引用访问对象的属性和方法，在程序运行过程中被不断使用。
+   销毁：当对象不再被引用时，通过垃圾回收机制自动回收对象所占用的内存空间。垃圾回收器会在适当的时候检测并回收不再被引用的对象，释放对象占用的内存空间，完成对象的销毁过程。
### Java中的对象状态

状态一：可触及态：从根节点开始，可以搜索到这个对象，也就是可以访问到这个对象，也有人将其称为可达状态。

状态二：可复活态：从根节点开始，无论如何都不能访问到这个对象，也就是说这个对象的所有引用都被释放，没有任何变量引用该对象了，

            但是该对象有可能在finalize()方法中再次被引用，从而复活。

状态三：不可触及态：对象的所有引用都被释放了，并且在对象的finalize()方法中没有复活，这样的话该对象就是不可触及状态。
### ***  类加载器有哪些？**

- 每个 Java 类都有一个引用指向加载它的 `ClassLoader`。

- 数组类不是通过 `ClassLoader` 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。

![img](https://cdn.xiaolincoding.com//picgo/1719491243997-d62ceba6-2073-41a6-8320-dbe47ce9dbe4.png)

+   **启动类加载器（Bootstrap Class Loader）**：这是最顶层的类加载器，负责加载Java的核心库（\lib），它是用C++编写的，是JVM的一部分。启动类加载器无法被Java程序直接引用。

> 不是Java类，而是JVM自身的一部分（用C/C++实现），在Java中无法直接引用，因此返回null

+   **扩展类加载器（Extension Class Loader）**：它是Java语言实现的，继承自ClassLoader类，负责加载Java扩展目录（\lib\ext）下的jar包和类库。扩展类加载器由启动类加载器加载，并且父加载器就是启动类加载器。
+   **应用程序类加载器（Application Class Loader）**：这也是Java语言实现的，负责加载用户类路径（ClassPath）上的指定类库，是我们平时编写Java程序时默认使用的类加载器。系统类加载器的父加载器是扩展类加载器。它可以通过ClassLoader.getSystemClassLoader()方法获取到。
+   **自定义类加载器（Custom Class Loader）**：开发者可以根据需求定制类的加载方式，比如从网络加载class文件、数据库、甚至是加密的文件中加载类等。自定义类加载器可以用来扩展Java应用程序的灵活性和安全性，是Java动态性的一个重要体现。

这些类加载器之间的关系形成了双亲委派模型，其核心思想是当一个类加载器收到类加载的请求时，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。

只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

> **JVM 判定两个 Java 类是否相同的具体规则**：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 `Class` 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。

###  * **讲一下类加载过程？（类加载机制）**

类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括以下 **7** 个阶段：

![img](https://cdn.xiaolincoding.com//picgo/1719491354969-a7c861d7-531e-45d3-a4aa-4696710ec297.webp)

1. **加载**：
   - 通过一个类的==全限定名来获取定义此类的二进制字节流==。
   - 将这个字节流所代表的==静态存储结构转化为方法区的运行时数据结构==
   - 在==内存中生成一个代表这个类的java.lang.Class对象==，作为方法区这个类的各种数据的访问入口。

2. **验证**：确保Class文件的字节流中包含的信息符合《==Java虚拟机规范==》的全部约束要求
3. **准备**：为类中定义的变量（即==静态变量==，被static修饰的变量）<u>分配内存</u>并设置类变量<u>初始值</u>的阶段
4. **解析**：将常量池内的==符号引用替换为直接引用的过程==
5. **初始化**：初始化阶段就是执行类构造器 `<clinit>()`方法的过程。
   - 要注意的是这里的构造器方法()并不是开发者写的，而是编译器自动生成的。
   - 当首次使用该类时，JVM 才会触发初始化。

6. **使用**
7. **卸载**
   - 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
   - 该类没有在其他任何地方被引用
   - 该类的类加载器的实例已被 GC


> 由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

###  * **创建对象的过程？**

![img](https://cdn.xiaolincoding.com//picgo/1713516384566-e820b967-73ce-49a4-a6e6-36af9a38ebc4.webp)在Java中创建对象的过程包括以下几个步骤：

1.  **类加载检查**：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在==常量池==中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
2.  **分配内存**：在类加载检查通过后，接下来虚拟机将为新生对象==分配内存==。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种
    - ==指针碰撞：== 
      - 适用场合：堆内存规整（即没有内存碎片）的情况下。（标记整理、复制）
      - 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
      - 使用该分配方式的 GC 收集器：Serial, ParNew
    - ==空闲列表：== 
      - 适用场合：堆内存不规整的情况下。(标记清除)
      - 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
      - 使用该分配方式的 GC 收集器：CMS

3. **初始化零值**：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

4. **设置对象头**：初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

5. **执行 init 方法**：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始——构造函数，即class文件中的方法还没有执行，所有的字段都还为零，对象需要的其他资源和状态信息还没有按照预定的意图构造好。所以一般来说，执行 new 指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全被构造出来。

### 虚拟机如何保证并发情况下创建对象的线程安全

虚拟机采用两种方式来保证线程安全：

- ==CAS+失败重试==
- ==TLAB==（Thread-Local Allocation Buffer）： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

###  双亲委派原则

**当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做**。

使用委派模型的目的是**保证 Java 核心类（如 java.lang.String）不被覆盖，避免重复加载 Java 类型。**

> 类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。

#### 作用

+   **保证类的唯一性**：通过委托机制，确保了所有加载请求都会传递到启动类加载器，避免了不同类加载器重复加载相同类的情况，保证了Java核心类库的统一性，也防止了用户自定义类覆盖核心类库的可能。
+   **保证安全性**：由于Java核心库被启动类加载器加载，而启动类加载器只加载信任的类路径中的类，这样可以防止不可信的类假冒核心类，增强了系统的安全性。例如，恶意代码无法自定义一个Java.lang.System类并加载到JVM中，因为这个请求会被委托给启动类加载器，而启动类加载器只会加载标准的Java库中的类。
+   **支持隔离和层次划分**：双亲委派模型支持不同层次的类加载器服务于不同的类加载需求，如应用程序类加载器加载用户代码，扩展类加载器加载扩展框架，启动类加载器加载核心库。这种层次化的划分有助于实现沙箱安全机制，保证了各个层级类加载器的职责清晰，也便于维护和扩展。
+   **简化了加载流程**：通过委派，大部分类能够被正确的类加载器加载，减少了每个加载器需要处理的类的数量，简化了类的加载过程，提高了加载效率。

#### 破坏双亲委派

<img src="./4.Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20250404092935720.png" alt="image-20250404092935720" style="zoom:50%;" />

双亲委派的具体逻辑就实现在这里面， 按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载

- 用户**自定义类加载器直接重写`loadClass()`方法**，绕过了双亲委派逻辑。
- 通过**线程上下文类加载器（Thread Context ClassLoader）** 逆向委派，由父类加载器（如启动类加载器）请求子类加载器（如应用类加载器）加载SPI实现类。
- OSGi采用**网状类加载器结构**，每个模块（Bundle）拥有独立的类加载器，类加载时按优先级在平级模块间委派，而非严格遵循父委派。

> 原因：
>
> - JDK 1.2引入双亲委派模型时，需兼容早期已存在的自定义类加载器代码，无法强制要求开发者遵循新模型。
> - 基础服务（如JNDI、JDBC）需要加载由用户提供的SPI实现
> - 实现模块热替换、热部署等动态性需求，允许在不重启应用的情况下更新代码。

> Tomcat 为了实现==每个 WebApp 的类相互隔离==，不得不打破双亲委派机制，改为 “当前优先” 或 “自定义委派规则”。

##  垃圾回收

###  什么是Java里的垃圾回收？如何触发垃圾回收？

垃圾回收（Garbage Collection, GC）是自动管理内存的一种机制，它负责自动释放不再被程序引用的对象所占用的内存，这种机制减少了内存泄漏和内存管理错误的可能性。垃圾回收可以通过多种方式触发，具体如下：

+   **内存不足时**：当JVM检测到堆内存不足，无法为新的对象分配内存时，会自动触发垃圾回收。
+   **手动请求**：虽然垃圾回收是自动的，开发者可以通过调用 `System.gc()` 或 `Runtime.getRuntime().gc()` 建议 JVM 进行垃圾回收。不过这只是一个建议，并不能保证立即执行。
+   **JVM参数**：启动 Java 应用时可以通过 JVM 参数来调整垃圾回收的行为，比如：`-Xmx`（最大堆大小）、`-Xms`（初始堆大小）等。
+   **对象数量或内存使用达到阈值**：垃圾收集器内部实现了一些策略，以监控对象的创建和内存使用，达到某个阈值时触发垃圾回收。

###  *** 判断垃圾的方法有哪些？**

在Java中，判断对象是否为垃圾（即不再被使用，可以被垃圾回收器回收）主要依据两种主流的垃圾回收算法来实现：**引用计数法和可达性分析算法**。

> 引用计数法（Reference Counting）

+   **原理**：为每个对象分配一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1。当计数器为0时，表示对象不再被任何变量引用，可以被回收。
+   **缺点**：不能解决循环引用的问题，即两个对象相互引用，但不再被其他任何对象引用，这时引用计数器不会为0，导致对象无法被回收。

<u>目前主流的虚拟机中并没有选择这个算法来管理内存</u>，其最主要的原因是它很难解决对象之间循环引用的问题。

> 可达性分析算法（Reachability Analysis）

![img](https://cdn.xiaolincoding.com//picgo/1719111821599-650b1691-2737-453b-ba4b-26b065a96e88.png)

Java虚拟机主要采用此算法来判断对象是否为垃圾。

+   **原理**：从一组称为GC Roots（垃圾收集根）的对象出发，向下追溯它们引用的对象，以及这些对象引用的其他对象，以此类推。如果一个对象到GC Roots没有任何引用链相连（即从GC Roots到这个对象不可达），那么这个对象就被认为是不可达的，可以被回收。
+   **GC Roots对象包括**：
    +   <u>虚拟机栈</u>(栈帧中的局部变量表)中引用的对象
    +   <u>本地方法栈</u>(Native 方法)中引用的对象
    +   <u>方法区</u>中类静态属性引用的对象
    +   <u>方法区</u>中常量引用的对象
    +   所有被<u>同步锁</u>持有的对象
    +   <u>JNI</u>（Java Native Interface）引用的对象


> GC Root 必须是“天然存活”的（除了堆中的对象，因为这些对象本身的生命周期并没有内置于 JVM 的生命周期或线程栈中，而是完全取决于是否有其他可达引用指向它们。）

### 对象可以被回收，就代表一定会被回收吗？

==不是。==要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 `finalize` 方法。当对象没有覆盖 `finalize` 方法，或 `finalize` 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行

### *** 三色标记法**

将堆中的对象分为三种颜色：白（White）、灰（Grey） 和 黑（Black）。在标记扫描的过程中，不断地更新对象所属集合，以保证算法的正确性。

- 白色（White）：尚未被 GC 标记到，暂时视为“不可达”或“待确认”。
- 灰色（Grey）：表示对象本身已经被标记为<u>可达</u>，但它<u>引用</u>的其他对象还<u>没有被扫描</u>。
- 黑色（Black）：表示对象不仅被标记为<u>可达</u>，而且它<u>引用</u>的所有对象也都已经<u>标记完成</u>，或者已经进入待扫描列表

当对象从黑色转变后，应用线程仍可能把它的引用指向一个白色对象，导致漏标。而三色标记法通过 屏障技术 解决了这个问题，保证 GC 不变式

- ==写屏障==：触发于应用线程写入引用对象
  - 处理“**黑色对象引用白色对象**”的问题（漏标），当应用线程要给一个黑色对象的字段写入一个白色对象的引用时，<u>写屏障会将那个白色对象变为灰色</u>（确保 GC 不会漏扫描该白色对象）。
- ==读屏障==：触发于应用线程读取引用对象
  - **并发移动对象**：GC 将对象从旧地址移动到新地址，但应用线程还不知道这个对象已经搬家，继续访问旧地址可能出错
  - **指针着色**：GC 对指针做了某些“着色”处理（在指针的某些比特中嵌入对象状态、转发信息等），读屏障需要在应用线程获取指针时确认并执行指针修正、检查或解码。

> 在 GC 标记开始时，几乎所有对象都可以看作是 **白色**。然后从 GC Roots 开始，将可达的对象标记为灰色，并不断扫描灰色对象引用到的其他对象。如果一个灰色对象引用到的对象是白色，就把它变成灰色；扫描结束后，把当前灰色对象变成黑色，直到再没有灰色对象为止。最后，在标记阶段结束时依然保持白色的对象就可以被回收。

###  垃圾回收算法是什么，是为了解决了什么问题？

JVM有垃圾回收机制的原因是为了解决内存管理的问题。在传统的编程语言中，开发人员需要手动分配和释放内存，这可能导致==内存泄漏、内存溢出==等问题。而Java作为一种高级语言，旨在提供更简单、更安全的编程环境，因此引入了垃圾回收机制来自动管理内存。

垃圾回收机制的主要目标是**自动检测和回收**不再使用的对象，从而释放它们所占用的内存空间。这样可以避免内存泄漏（一些对象被分配了内存却无法被释放，导致内存资源的浪费）。同时，垃圾回收机制还可以防止内存溢出（即程序需要的内存超过了可用内存的情况）。

通过垃圾回收机制，JVM可以在程序运行时自动识别和清理不再使用的对象，使得开发人员无需手动管理内存。这样可以提高开发效率、减少错误，并且使程序更加可靠和稳定。

### *** 垃圾回收算法有哪些？**

+   **标记-清除算法**：标记-清除算法分为“标记”和“清除”两个阶段，首先通过==可达性分析==，标记出所有需要回收的对象，然后统一回收所有被标记的对象。标记-清除算法有两个缺陷，一个是效率问题，标记和清除的过程效率都不高，另外一个就是，清除结束后会造成大量的碎片空间。有可能会造成在申请大块内存的时候因为没有足够的连续空间导致再次 GC。、
    +   实现简单；最初的 GC 算法都从此衍生。
    +   传统的单线程标记-清除通常会完全 STW
    +   现代 JVM 中改造为多线程或并发执行，但仍需要在某些时刻做小范围或最终的 STW 来完成清理或一致性操作。
+   **复制算法**：为了解决碎片空间的问题，出现了“复制算法”。复制算法的原理是，==将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时，将这一块内存中所有存活的复制到另一块上==。然后将然后再把已使用的内存整个清理掉。复制算法解决了空间碎片的问题。但是也带来了新的问题。因为每次在申请内存时，都只能使用一半的内存空间。内存利用率严重不足。
    +   分配和回收简便，不会产生内存碎片；对新生代高频次回收效率高。
    +   复制阶段通常需要暂停应用线程
+   **标记-整理算法**：复制算法在 GC 之后存活对象较少的情况下效率比较高，但如果存活对象比较多时，会执行较多的复制操作，效率就会下降。而老年代的对象在 GC 之后的存活率就比较高，所以就有人提出了“标记-整理算法”。标记-整理算法的“标记”过程与“标记-清除算法”的标记过程一致，但==标记之后不会直接清理。而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分==。
    +   移动对象后，内存是连续的，不会产生碎片；有利于大对象分配。
    +   整理 / 压缩 阶段需要完全 STW
+   **分代回收算法**：分代收集是将内存划分成了新生代和老年代。分配的依据是对象的生存周期，或者说经历过的 GC 次数。对象创建时，一般在新生代申请内存，当经历一次 GC 之后如果对还存活，那么对象的年龄 +1。当年龄超过一定值(默认是 15，可以通过参数 -XX:MaxTenuringThreshold 来设定)后，如果对象还存活，那么该对象会进入老年代。
    +   新生代对象死亡率高，采用**复制算法**；
    +   老年代对象存活率高，多用**标记-整理** 或其他并发收集方式
    +   永久代（Perm Generation）：主要存放元数据，例如Class、Method的元信息，与垃圾回收要回收的Java对象关系不大。相对于新生代和年老代来说，该区域的划分对垃圾回收影响比较小。
    +   ==当代主流虚拟机（Hotspot VM）的垃圾回收都采用“分代回收”的算法==


> 在 传统的串行或并行 GC（如 Serial/Parallel GC）中，标记阶段一般完全 STW，即应用线程全部暂停直到标记完成。
>
> 在 并发 GC（如 CMS、G1、ZGC、Shenandoah）中，标记大部分是与应用线程并发执行的，但往往仍需在==初始标记和最终重新标记==阶段进行 短暂的 STW。
>
> - 最终重新标记：目的在于“**收集并处理并发阶段漏掉或迟到的引用更新**”

### *** 垃圾回收器有哪些？**

![img](https://cdn.xiaolincoding.com//picgo/1712649527581-d6aee0bf-35ab-4406-8a26-270b35ae8771.png)

+   Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；
+   Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；
+   ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；
+   Parallel Scavenge收集器 (==复制算法): 新生代==并行收集器，追求==高吞吐量==，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；
+   Parallel Old收集器 (==标记-整理算法)： 老年代==并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；
+   CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： ==老年代==并行收集器，以获取==最短回收停顿时间==为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。
+   G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代
+   ZGC：主要面向需要大堆内存（TB 级别）且对暂停时间要求极低的场景

![image-20250324151657140](./Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20250324151657140.png)



###  标记清除算法的缺点是什么？

主要缺点有两个：

+   第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；
+   另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

###  垃圾回收算法哪些阶段会stop the world?

> **枚举根节点**时也是必须要停顿的。
>
> 通常**标记-清除算法**也是需要停顿用户线程来标记、清理可回收对象的，只是停顿时间相对而言要来的短而已。
>
> **对象移动**操作必须全程暂停用户应用程序才能进行 

标记-复制算法应用在CMS新生代（ParNew是CMS默认的新生代垃圾回收器）和G1垃圾回收器中。标记-复制算法可以分为三个阶段：

+   标记阶段，即从GC Roots集合开始，标记活跃对象；
+   转移阶段，即把活跃对象复制到新的内存地址上；
+   重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。

下面以G1为例，通过G1中标记-复制算法过程（G1的Young GC和Mixed GC均采用该算法），分析G1停顿耗时的主要瓶颈。G1垃圾回收周期如下图所示：

![img](https://cdn.xiaolincoding.com//picgo/1718783586342-9da40db7-1dac-42ec-8148-81c10d8bfc04.png)

G1的混合回收过程可以分为标记阶段、清理阶段和复制阶段。

**标记阶段停顿分析**

+   初始标记阶段：初始标记阶段是指从GC Roots出发标记全部直接子节点的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。
+   并发标记阶段：并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。
+   再标记阶段：重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。

**清理阶段停顿分析**

+   清理阶段清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的。

**复制阶段停顿分析**

+   复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。

四个STW过程中，初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。

因此，G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW。

###  **minorGC、majorGC、fullGC的区别，什么场景触发full GC**

在Java中，垃圾回收机制是自动管理内存的重要组成部分。根据其作用范围和触发条件的不同，可以将GC分为三种类型：Minor GC（也称为Young GC）、Major GC（有时也称为Old GC）、以及Full GC。以下是这三种GC的区别和触发场景：

> Minor GC (Young GC)

+   **作用范围**：只针对年轻代进行回收，包括Eden区和两个Survivor区（S0和S1）。
+   **触发条件**：当Eden区空间不足时，JVM会触发一次Minor GC，将Eden区和一个Survivor区中的存活对象移动到另一个Survivor区或老年代（Old Generation）。
+   **特点**：通常发生得非常频繁，因为年轻代中对象的生命周期较短，回收效率高，暂停时间相对较短。

> Major GC

+   **作用范围**：主要针对老年代进行回收，但不一定只回收老年代。
+   **触发条件**：当==老年代空间不足时==，或者系统检测到年轻代对象晋升到老年代的速度过快，可能会触发Major GC。
+   **特点**：相比Minor GC，Major GC发生的频率较低，但每次回收可能需要更长的时间，因为老年代中的对象存活率较高。

> Mixed GC

- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

> Full GC

+   **作用范围**：对整个堆内存（包括年轻代、老年代以及永久代/元空间）进行回收。
    
+   **触发条件**：
    
    +   ==直接调用`System.gc()`或`Runtime.getRuntime().gc()`方法==时，虽然不能保证立即执行，但JVM会尝试执行Full GC。
        
    +   ==Minor GC（新生代垃圾回收）时，如果存活的对象无法全部放入老年代，或者老年代空间不足以容纳存活的对象==，则会触发Full GC，对整个堆内存进行回收。
        
    +   当永久代或==元空间空间不足时==。
    
+   **特点**：Full GC是最昂贵的操作，因为它需要停止所有的工作线程（Stop The World），遍历整个堆内存来查找和回收不再使用的对象，因此应尽量减少Full GC的触发。
    

###  垃圾回收器 CMS 和 G1的区别？

**区别一：使用的范围不一样：**

+   CMS收集器是==老年代==的收集器，可以配合新生代的Serial和ParNew收集器一起使用
+   G1收集器收集范围是==老年代和新生代==。不需要结合其他收集器使用

**区别二：STW的时间：**

+   CMS收集器==以最小的停顿时间为目标==的收集器。
+   G1收集器==可预测垃圾回收的停顿时间==（建立可预测的停顿时间模型）

**区别三： 垃圾碎片**

+   CMS收集器是使用“==标记-清除==”算法进行的垃圾回收，容易产生内存碎片
+   G1收集器使用的是“==标记-整理==”算法，进行了空间整合，没有内存空间碎片。

**区别四： 垃圾回收的过程不一样**

![img](https://cdn.xiaolincoding.com//picgo/1716015294690-efd71a12-f4b1-4356-9de2-5164393482a5.png)

注意这两个收集器==第四阶段不同==

> 筛选回收：从所有可回收的 Region 中筛选回收效率最高的部分先执行，后续再逐步收集剩余的 Region。<u>在可预测的停顿时间内最大化回收收益</u>

**区别五: CMS会产生浮动垃圾**

+   CMS产生浮动垃圾过多时会退化为serial old，效率低，因为在上图的第四阶段，CMS清除垃圾时是并发清除的，这个时候，垃圾回收线程和用户线程同时工作会产生浮动垃圾，也就意味着CMS垃圾回收器必须预留一部分内存空间用于存放浮动垃圾
+   而G1没有浮动垃圾，G1的筛选回收是多个垃圾回收线程并行gc的，没有浮动垃圾的回收，在执行‘并发清理’步骤时，用户线程也会同时产生一部分可回收对象，但是这部分可回收对象只能在下次执行清理是才会被回收。如果在清理过程中预留给用户线程的内存不足就会出现‘Concurrent Mode Failure’,一旦出现此错误时便会切换到SerialOld收集方式。

###  什么情况下使用CMS，什么情况使用G1?

CMS适用场景：

+   **低延迟需求**：适用于对停顿时间要求敏感的应用程序。
+   **老生代收集**：主要针对老年代的垃圾回收。
+   **碎片化管理**：容易出现内存碎片，可能需要定期进行Full GC来压缩内存空间。

G1适用场景：

+   **大堆内存**：适用于需要管理大内存堆的场景，能够有效处理数GB以上的堆内存。
+   **对内存碎片敏感**：G1通过紧凑整理来减少内存碎片，降低了碎片化对性能的影响。
+   **比较平衡的性能**：G1在提供较低停顿时间的同时，也保持了相对较高的吞吐量。

###  G1回收器的特色是什么？

**G1 的特点：**

+   G1最大的特点是==引入分区的思路==，弱化了分代的概念。
+   合理利用垃圾收集各个周期的资源，解决了其他收集器、甚至 CMS 的众多缺陷

**G1 相比较 CMS 的改进：**

+   **算法**： G1 基于标记--整理算法, 不会产生空间碎片，在分配大对象时，不会因无法得到连续的空间，而提前触发一次 FULL GC 。
+   **停顿时间可控**： G1==可以通过设置预期停顿时间==（Pause Time）来控制垃圾收集时间避免应用雪崩现象。
+   **并行与并发**：G1 能更充分的利用 CPU 多核环境下的硬件优势，来缩短 stop the world 的停顿时间。

###  GC只会对堆进行GC吗？

JVM 的垃圾回收器不仅仅会对堆进行垃圾回收，它还会对方法区进行垃圾回收。

1.  **堆（Heap）：** 堆是用于存储对象实例的内存区域。大部分的垃圾回收工作都发生在堆上，因为大多数对象都会被分配在堆上，而垃圾回收的重点通常也是回收堆中不再被引用的对象，以释放内存空间。
2.  **方法区（Method Area）：** 方法区是用于存储类信息、常量、静态变量等数据的区域。虽然方法区中的垃圾回收与堆有所不同，但是同样存在对不再需要的常量、无用的类信息等进行清理的过程。

* * *

### 如何优化垃圾回收的性能？

| **优化方向** | **方法**                     |
| ------------ | ---------------------------- |
| 代码层面     | 减少对象创建，及时释放引用   |
| 内存分配     | 合理设置新生代/老年代比例    |
| GC 策略      | 根据场景选择合适的 GC        |
| 性能监控     | 使用工具发现瓶颈，针对性调参 |

## JVM参数

为 JVM 分配最小 2 GB 和最大 5 GB 的堆内存大小

```java
-Xms2G /start
-Xmx5G /max
```

为 新生代分配 最小 256m 的内存，最大 1024m 的内存

```java
-XX:NewSize=256m
-XX:MaxNewSize=1024m
```

元空间

```java
-XX:MetaspaceSize=N 
-XX:MaxMetaspaceSize=N #设置 Metaspace 的最大大小
```

MetaspaceSize 表示 Metaspace 使用过程中==触发 Full GC 的阈值==，只对触发起作用。

垃圾回收器

```java
-XX:+UseSerialGC
-XX:+UseParallelGC
-XX:+UseConcMarkSweepGC
-XX:+UseG1GC
```

GC 日志记录

```java
# 必选
# 打印基本 GC 信息
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
# 打印对象分布
-XX:+PrintTenuringDistribution
# 打印堆数据
-XX:+PrintHeapAtGC
# 打印Reference处理信息
# 强引用/弱引用/软引用/虚引用/finalize 相关的方法
-XX:+PrintReferenceGC
# 打印STW时间
-XX:+PrintGCApplicationStoppedTime

# 可选
# 打印safepoint信息，进入 STW 阶段之前，需要要找到一个合适的 safepoint
-XX:+PrintSafepointStatistics
-XX:PrintSafepointStatisticsCount=1

# GC日志输出的文件路径
-Xloggc:/path/to/gc-%t.log
# 开启日志文件分割
-XX:+UseGCLogFileRotation
# 最多分割几个文件，超过之后从头文件开始写
-XX:NumberOfGCLogFiles=14
# 每个文件上限大小，超过就触发分割
-XX:GCLogFileSize=50M
```



## 淘天

### * cpu一直空转jvm怎么处理

- 第一可以使用使用**top**命令查看占用cpu的情况
- 第二通过top命令查看后，可以查看是哪一个进程占用cpu较高，记录这个进程id
- 第三可以通过**ps** 查看当前进程中的线程信息，看看哪个线程的cpu占用较高
- 第四可以**jstack**命令打印进行的id，找到这个线程，就可以进一步定位问题代码的行号

### * jvm如何给对象分配内存，具体有哪些方法

1.TLAB（线程局部分配缓冲区）分配

每个线程在创建时会分配一个私有的内存区域，称为TLAB。线程在分配新对象时，首先在自己的TLAB内直接进行分配，避免了多线程竞争。这种方式简单高效，通常使用**指针碰撞（Bump-the-pointer）算法**进行内存分配。

2.指针碰撞算法（Bump-the-pointer Allocation）

当堆内存中的某一块区域连续可用时，JVM只需将一个指针向前移动，为新对象分配连续空间。这种方法速度非常快，因为它仅仅是修改指针而无需进行复杂的数据结构查找。

3.空闲列表分配（Free List Allocation）

在老年代或内存碎片较多的情况下，连续内存区域可能不足，此时JVM会维护一个空闲列表，记录各个内存块的大小和位置，然后从中挑选合适的内存块来分配给对象。由于需要搜索合适的内存块，速度会比指针碰撞慢一些。

4.大对象直接分配

对于超过一定阈值的大对象（如大数组或复杂对象），通常无法在TLAB中分配，这类对象直接在老年代中分配，以避免因大对象频繁触发GC而影响整体性能。

### *什么是逃逸分析，为什么要这么做？

逃逸分析会==检查一个对象的引用是否仅限于当前方法、代码块或线程内部==。如果对象没有被外部方法或其他线程引用，就认为该对象没有“逃逸”。

1. **栈上分配优化**

如果逃逸分析确定一个对象不会逃逸当前方法或线程，则可以将其分配在栈上而非堆上。栈上分配的对象生命周期与方法调用周期一致，分配和销毁开销更低，同时减少了GC的压力。

2. **标量替换（Scalar Replacement）**

当逃逸分析确定一个对象只在局部使用时，可以将该对象的各个字段直接作为独立的基本数据类型变量来优化。这样就不需要实际分配对象，从而进一步降低内存分配和垃圾回收的负担。

3. **锁消除（Lock Elision）**

在多线程环境中，如果对象被用作锁的对象，而逃逸分析证明该对象不会被其他线程访问，那么JVM就可以消除不必要的同步操作，避免加锁和解锁的开销，提升并发性能。

### * JVM的隔离机制

JVM 的隔离机制贯穿于不同层次：

•      **操作系统层面**：通过独立进程实现内存和资源隔离。

•	**类加载器层面**：提供命名空间隔离，防止类之间冲突。

•	**线程与栈层面**：确保线程局部数据的独立性，同时通过 Java 内存模型管理共享内存。

•	**安全与模块层面**：通过安全管理器和模块系统，进一步限制代码的权限和访问范围。

### * 双亲委派怎么打破？具体的方法？

为什么要打破它？ 

- 不同模块可加载不同版本的同名类
- 每次重新加载类，避免 JVM 固化
- 避免用到旧的或错误的父类实现

打破方法：

自定义类加载器，==继承ClassLoader，重写 **loadClass**(String name, boolean resolve) 方法==

> 如果我们不想打破双亲委派模型，就重写 `ClassLoader` 类中的 `findClass()` 方法即可
>

### * graalvm

**GraalVM 既是 JVM 的一个实现，又是一个更广泛的多语言运行平台。**

| **组件**               | **说明**                                                     |
| ---------------------- | ------------------------------------------------------------ |
| **JVM（HotSpot）**     | 是的，GraalVM 基于 OpenJDK 的 JVM（HotSpot），所以它当然能运行 Java |
| **Graal JIT Compiler** | 替代传统的 C2 编译器，提高性能                               |
| **Truffle 语言框架**   | 用来支持运行 JavaScript、Python 等非 JVM 语言                |
| **Native Image 工具**  | 可以将 Java 应用编译为原生机器码（不需要 JVM）               |
| **Polyglot API**       | 让不同语言之间可以互相调用                                   |

## 深入理解Java虚拟机

### * **堆溢出，经常gc如何排查？**

```
-Xms20m -Xmx20m
```

首先通过内存映像分析工具对 Dump 出来的**堆转储文件**进行分析。

第一步首先应确认内存中导致OOM的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。

如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的，那就应当检查Java虚拟机的堆参数（-Xmx与-Xms）设置，与机器的内存对比，看看是否还有向上调整的空间。

再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。

> 通过参数`-XX：+Heap Dump OnOutOf-MemoryError`可以让虚拟机在出现内存溢出异常的时候Dump出当前的内存堆转储快照以便进行事后分析
>
> “Dump”通常指的是捕捉应用程序当前内存状态的过程，常用于分析内存使用情况、检测内存泄漏等问题

### 虚拟机栈和本地方法栈溢出

```
由-Xss参数来设定
```

1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。

2）如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出 OutOfM emoryError异常。

操作系统分配给每个进程的内存是有限制的，在不能减少线程数量或者更换64位虚拟机的情况下，就只能通过减少最大堆和減少栈容量来换取更多的线程。

这种==通过“减少内存”的手段来解决内存溢出的方式==

### 方法区和运行时常量池溢出

```
-XX:PermSize=6M -XX:MaxPermSize=6M
```

### 跨代引用

每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为“**记忆集**”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。

### 安全点、安全区域

实际上<u>HotSpot也的确没有为每条指令都生成OopMap，只是在“特定的位置”记录了这些信息</u>，这些位置被称为**安全点**（Safepoint）。有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。

**安全区域**是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。

### 如何进入安全点？

**主动式中断**的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个==标志位==，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。

### 解决并发扫描时对象消失问题？

**增量更新**要破坏的是第一个条件，<u>当黑色对象插入新的指向白色对象的引用关系时</u>，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的<u>黑色对象根，重新扫描一次</u>。

**原始快照**要破坏的是第二个条件，<u>当灰色对象要删除指向白色对象的引用关系时，</u>就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的<u>灰色对象根，重新扫描一次</u>。

### **垃圾收集器**

JDK 8: Parallel Scavenge（新生代）+ Parallel Old（老年代）
JDK 9 ~ JDK22: G1

#### Serial收集器

![image-20250406141519986](./4.Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20250406141519986.png)

这个收集器是一个单线程工作的**新生代**收集器。**（使用复制算法）**

在它进行垃圾收集时，必须暂停其他所有工作线程（STW），直到它收集结束

Serial收集器对于运行在**客户端**模式下的虚拟机来说是一个很好的选择。

#### SerialOld收集器

Serial Old是Serial收集器的**老年代**版本，它同样是一个单线程收集器，使用**标记-整理**算法

一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是作为CMS 收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。

#### ParNew收集器

![image-20250406141531321](./4.Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20250406141531321.png)

ParNew收集器实质上是Serial收集器的多线程并行版本**（新生代，使用复制算法）**

是不少运行在**服务端**模式下的HotSpot虚拟机

==CMS 唯一支持的新生代收集器==

#### Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的**老年代**版本，支持多线程并发收集，基于**标记-整理**算法实现。

#### Parallel Scavenge收集器（吞吐量）

Parallel Scavenge收集器也是一款**新生代**收集器，它同样是**基于标记复制**算法实现的收集器

Parallel Scavenge 收集器关注点是**吞吐量**（高效率的利用 CPU）

所谓吞吐量就是处理器用于==运行用户代码的时间与处理器总消耗时间的比值==

Parallel Scavenge收集器还有一个参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。这种调节方式称垃圾收集的**自适应的调节策略**（GC Ergonomics）

#### CMS收集器

CMS（Concurrent Mark Sweep）收集器是一种以==获取最短回收停顿时间为目标==的**老年代**收集器。

##### 流程

1） 初始标记（CMS initial mark）

2）**并发标记**（CMS concurrent mark）

3）重新标记（CMS remark）

4）**并发清除**（CMS concurrent sweep）

其中==初始标记、重新标记==这两个步骤仍然需要“Stop The World”

##### 缺点

1. CMS收集器对处理器资源非常敏感。虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。
2. 无法处理“浮动垃圾”（Floating Garbage），有可能出现“Con-current M ode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称**“浮动垃圾”**。
3. 基于“**标记-清除**”算法实现的收集器，收集结束时会有大量空间碎片产生。

> CMS 垃圾回收器在 Java 9 中已经被标记为过时(deprecated)，并在 Java 14 中被移除。

#### Garbage First收集器（可控时间）

JDK 9发布，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器

衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的**Mixed GC**模式。

- G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），==每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。==

- Region中还有一类特殊的==Humongous区域，专门用来存储大对象==。G1认为只要大小超过了一个 Region容量一半的对象即可判定为大对象。

- G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即==每次收集到的内存空间都是Region大小的整数倍==。

- **重要：**G1收集器去==跟踪各个Region里面的垃圾堆积的“价值”大小==（垃圾占比和回收耗时），价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个==优先级列表==，每次根据用户设定允许的收集停顿时间，==优先处理回收价值收益最大的那些Region==， 这也就是“Garbage First”名字的由来。

> CMS收集器采用**增量更新**算法实现，而G1 收集器则是通过**原始快照**算法来实现的

##### 步骤

1. 初始标记（Initial Marking）

2. **并发标记**（Concurrent Marking）
3. 最终标记（Final Marking）

4. 筛选回收（Live Data Counting and Evacuation）

> 除了并发标记外，其余阶段也是要完全暂停用户线程的（STW）

##### 对比CMS优缺点

优点：可以==指定最大停顿时间、分Region的内存布局、按收益动态确定回收集==这些创新性设计带来的红利

缺点：在用户程序运行过程中，G1无论是为了垃圾收集产生的<u>内存占用</u> （Footprint）还是程序运行时的额外执行负载 （Overload）都要比CMS要高。

> 在小内存应用上CMS的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间

衡量垃圾收集器的三项最重要的指标是：**内存占用（Footprint）、吞吐量（Throughput）和延迟**

##### STW

在CMS和G1之前的全部收集器，其工作的**所有步骤**都会产生“Stop The World”式的停顿

Shenandoah和ZGC，几乎整个工作过程全部都是并发的，只有初始标记、最终标记这些阶段有短暂的停顿，这部分停顿的时间基本上是固定的，与堆的容量、堆中对象的数量==没有正比例关系==。被官方命名为“低延迟垃圾收集器"

#### Shenandoah收集器（略）

Shenandoah（目前）是默认不使用分代收集的，换言之，不会有专门的新生代Region或者老年代Region的存在，

Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名次“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题（见3.4.4节）的发生概率。

#### ZGC收集器（低延迟、大堆）

采用**标记复制**。ZGC 可以将暂停时间控制在几毫秒以内，且==暂停时间不受堆内存大小的影响，出现 Stop The World 的情况会更少，但代价是牺牲了一些吞吐量==。ZGC 最大支持 16TB 的堆内存。

> **ZGC 是为“低延迟 + 大堆 + 高并发”而生的收集器，适合对系统停顿极度敏感的应用场景。**

ZGC也采用基于Region的堆内存布局，但ZGC的Region具有动态性—动态创建和销毁，以及动态的区域容量大小。

- 小型Region（Small Region）：容量固定2MB，用于放置小于256KB的小对象。

- 中型Region （Medium Region）：容量固定32MB，用于放置大于等于256KB但小于4MB的对象。

- 大型Region （Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置 4MB或以上的大对象。每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型 Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配的，因为复制一个大对象的代价非常高昂。

ZGC收集器有一个标志性的设计是它采用的**染色指针**技术，直接把标记信息记在引用对象的指针上

染色指针优点：

- 染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。

- 染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。实际上，到目前为止ZGC都并未使用任何写屏障，只使用了读屏障
- 染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据

##### 工作流程

全部四个阶段都是可以并发执行的，仅是两个阶段中间会存在短暂的停顿小阶段

- 并发标记（Concurrent Mark）
- 并发预备重分配（Concurrent Prep are for Relocate）
- 并发重分配（Concurrent Relocate）
- 并发重映射（Concurrent Remap）

##### 优缺点

因为ZGC强调==低延迟（停顿时间很短==），因此垃圾回收的大量工作都被设计成并发执行（与业务线程同时进行）。但并发执行意味着：

- GC期间产生的短生命周期对象并未及时被纳入本次标记回收范围。
- 这些短暂存活的对象只能等到下一次回收时才能处理，从而形成大量浮动垃圾。

解决方法：

- 增大堆内存大小：给ZGC更多的空间用于并发回收时的缓冲。
- 使用分代ZGC（JDK 21起逐步引入）：分代设计使年轻代回收更加高效，短生命周期对象能更快回收。
- 降低应用对象分配速度：合理设计业务代码，减少瞬时的临时对象。

### 虚拟机及垃圾收集器日志

```
"-Xlog"
```

### **对象分配策略**

**对象优先在Eden分配：**大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次 Minor GCo

> 新生代分为eden 和 survivor0和survivor1，两个Survivor区总有一个是空闲的，用来交换存活对象。
>
> 默认比例通常为 Eden : S0 : S1 = 8 : 1 : 1

**大对象直接进入老年代：**在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们，而当复制对象时，大对象就意味着高额的内存复制开销。

- HotSpot虚拟机提供了-XX：PretenureSizeThreshold 参数，指定大于该设置值的对象直接在老年代分配
- G1 垃圾回收器会根据 `-XX:G1HeapRegionSize` 参数设置的堆区域大小和 `-XX:G1MixedGCLiveThresholdPercent` 参数设置的阈值，来决定哪些对象会直接进入老年代。
- Parallel Scavenge 垃圾回收器中，默认情况下，并没有一个固定的阈值(`XX:ThresholdTolerance`是动态调整的)来决定何时直接在老年代分配大对象。而是由虚拟机根据当前的堆内存情况和历史数据动态决定。

**长期存活的对象将进入老年代：**虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次 Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度==（默认15）==，就会被晋升到老年代中。

- 对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。
- 这个参数只对Serial和ParNew两款新生代收集器有效

**动态对象年龄判定**：如果在Survivor空间中相同年龄所有对象大小的总和大于 Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX： MaxTenuringThreshold中要求的年龄。

**空间分配担保**：在发生Minor GC之前，虚拟机必须==先检查老年代最大可用的连续空间是否大于新生代所有对象总空间==，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看`- XX:HandlePromotionFailure`参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允许，那会继续检查==老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小==，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者`-XX：HandlePromotionFailure`设置不允许冒险，那这时就要改为进行一次Full GC。

> 虽然担保失败时绕的圈子是最大的，但通常情况下都还是会将-XX：HandlePromotionFailure开关打开，避免Full GC过于频繁。
>
> 在JDK 6 Update 24之后规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行FullGC。

### 工具

**jps**：查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息

- 可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一 ID（LVMID，Local Virtual Machine Identifier）

**jstat**：虚拟机统计信息监视工具

- 可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据

jinfo：实时查看和调整虚拟机各项参数。

**jmap**（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）

jhat：分析jmap生成的堆转储快照。

**jstack**（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照

- 线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的 目的通常是定位线程出现长时间停顿的原因，如线程间==死锁、死循环==、请求外部资源导致的长时间挂 起等，都是导致线程长时间停顿的常见原因

#### 可视化

JConsole

### 类加载时机

#### 初始化

- 使用new关键字实例化对象的时候。
- 读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外） 的时候。
- 调用一个类型的静态方法的时候。
- 使用java.lang.reflect包的方法对类型进行反射调用的时候
- 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先 初始化这个主类。
- 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解 析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句 柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
- 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有 这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

### 验证具体验证什么

文件格式验证

- 是否以魔数0xCAFEBABE开头。

- 主、次版本号是否在当前Java虚拟机接受范围之内。

- 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。

- 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。

- CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。

- Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。

元数据验证

- 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。

- 这个类的父类是否继承了不允许被继承的类（被final修饰的类）。

- 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。

- 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方 法重载，例如方法参数都一致，但返回值类型却不同等）。

字节码验证

- ·保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作 栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。

- ·保证任何跳转指令都不会跳转到方法体以外的字节码指令上。

- ·保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全 的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个 数据类型，则是危险和不合法的。

符号引用验证

- 符号引用中通过字符串描述的全限定名是否能找到对应的类。

- ·在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。

- ·符号引用中的类、字段、方法的可访问性（private、protected、public、<package>）是否可被当 前类访问。

### 准备

### 解析

符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可

直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄

### 运行时栈帧

#### 局部变量表

局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义 的局部变量。

### 类型擦除

直接在编译时把`ArrayList<Integer>`还原 回ArrayList，只在元素访问、修改时自动插入一些强制类型转换和检查指令

```java
public class GenericTypes {
	public static void method(List<String> list) { 
    System.out.println("invoke method(List<String> list)"); 
  }
	public static void method(List<Integer> list) { 				  System.out.println("invoke method(List<Integer> list)"); 
  }
}
```

这段代码是不能被编译的，因为参数`List<Integer>`和`List<String>`编译之后都被擦除了，变成了同一种的裸类型List

### **逃逸分析**

逃逸分析的基本原理是：分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部 方法所引用，例如作为调用参数传递到其他方法中，这种称为**方法逃逸**；甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为**线程逃逸**；从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。

如果编译器分析发现某个对象仅在方法内部使用，并且不会被返回或者赋值给外部的变量，那么它就认为这个对象没有逃逸。

**栈上分配：**对象所占用的内存空间就可以随栈帧出栈而销毁。支持方法逃逸，但不能支持线程逃逸

**标量替换：**如果把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换

**同步消除**

> Java的对象不是一定在堆中分配的：
>
> - JVM会先进行==标量替换==，是否能够在栈上分配，如果栈上分配失败，才会在堆上分配。

### **Java内存模型JMM(Java Memory Model)**

Java 的内存模型实现总是从 ==主存== （即共享内存）读取变量

线程可以把变量保存 ==本地内存== （比如机器的寄存器）中，而不是直接在主存中进行读写

主内存：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量，还是局部变量，类信息、常量、静态变量都是放在主内存中。

本地内存：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的副本。每个线程只能操作自己本地内存中的变量，无法直接访问其他线程的本地内存。如果线程间需要通信，必须通过主内存来进行。本地内存是 JMM 抽象出来的一个概念，并不真实存在

![image-20250406101322570](./4.Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20250406101322570.png)



### 对于volatile型变量的特殊规则

==第一项是保证此变量对所有线程的可见性==，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。比如， 线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再对主内存进行读取操作，新变量值才会对线程B可见。

> volatile变量的运算在并发下一样是不安全的

使用volatile变量的第二个语义是==禁止指令重排序优化==，普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的 执行顺序一致。

### 原子性

由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个

如果应用场景需要一个更大范围的原子性保证，==synchronized块==之间的操作也具备原子性。

### 可见性

除了==volatile==之外，Java还有两个关键字能实现可见性，它们是==synchronized和final。==

> 被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去，那么在其他线程中就能看见final字段的值

### 有序性

提供了volatile和synchronized两个关键字来保证线程之间操作的有序性

### **Happens-Before**

前一个==操作的结果==对于后一个操作是可见的，无论这两个操作是否在同一个线程里。

### Java线程

每一个Java线程都是直接映射到一个操作系统原生线程来实现的

> HotSpot自己是不会去干涉线程调度的（可以设置线程优先级给操作系统提 供调度建议），全权交给底下的操作系统去处理，所以何时冻结或唤醒线程、该给线程分配多少处理 器执行时间、该把线程安排给哪个处理器核心去执行等，**都是由操作系统完成**的，也都是由操作系统 全权决定的。

线程调度是指系统为线程分配处理器使用权的过程，调度主要方式有两种，分别是==协同式== （Cooperative Threads-Scheduling）线程调度和==抢占式==（Preemptive Threads-Scheduling）线程调度。

#### 线程状态转换

1. 新建（New）：创建后尚未启动的线程处于这种状态。 
2. 运行（Runnable）：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可 能正在执行，也有可能正在等待着操作系统为它分配执行时间。 
3. 无限期等待（Waiting）：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线 程显式唤醒。以下方法会让线程陷入无限期的等待状态：
   - 没有设置Timeout参数的Object::wait()方法；

   - 没有设置Timeout参数的Thread::join()方法；

   - LockSupport::park()方法。

4. 限期等待（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待 被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：
   - Thread::sleep()方法；

   - 设置了Timeout参数的Object::wait()方法；

   - 设置了Timeout参数的Thread::join()方法；

   - LockSupport::parkNanos()方法；

   - LockSupport::parkUntil()方法。

5. 阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到 一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时 间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。 
6. 结束（Terminated）：已终止线程的线程状态，线程已经结束执行。

![image-20250404103924107](./4.Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20250404103924107.png)

### ReentrantLock

ReentrantLock与synchronized相比增加了一些高级功能，主要有以下三项：==等待可中断、可实现公平锁及锁可以绑定多个条件。==

- 等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改 为处理其他事情。
- 公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁
- 锁绑定多个条件：是指一个ReentrantLock对象可以同时绑定多个Condition对象

### CAS

CAS指令需要有三个操作数，分别是内存位置（在Java中可以简单地理解为变量的内存地址，用V 表示）、旧的预期值（用A表示）和准备设置的新值（用B表示）。CAS指令执行时，当且仅当V符合 A时，处理器才会用B更新V的值，否则它就不执行更新。但是，不管是否更新了V的值，都会返回V的 旧值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断。

如果一个变量V初次读取的时候是A 值，并且在准备赋值的时候检查到它仍然为A值，那就能说明它的值没有被其他线程改变过了吗？这 是不能的，因为如果在这段期间它的值曾经被改成B，后来又被改回为A，那CAS操作就会误认为它从 来没有被改变过。这个漏洞称为CAS操作的“ABA问题”。J.U.C包为了解决这个问题，提供了一个带有 标记的原子引用类**AtomicStampedReference**，它可以通过控制变量值的版本来保证CAS的正确性。

### ThreadLocal

每一个线程的Thread对象中都 有一个ThreadLocalMap对象，这个对象存储了一组以**ThreadLocal.threadLocalHashCode为键**，以**本地线程变量**为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个 ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对 中找回对应的本地线程变量。

### 自旋锁与自适应自旋

能让两个或以上的线程同时并行执行，我们 就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很 快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，这就会带来性能的浪费

**自适应的自旋**。自适应意味着自旋的时间不再是固定的了，而是<u>由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的</u>。如果在同一个锁对象上，自旋等待刚 刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成 功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。另一方面，如果对于某个锁，自 旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资 源。

### 锁消除

锁消除是JVM的一种优化技术，当JIT编译器通过**逃逸分析**（Escape Analysis）确定某段同步代码 **不存在共享数据竞争** 时，会直接移除同步锁（如`synchronized`块），从而减少不必要的性能开销。

### 锁粗化

如果虚拟机探测到有这样一串零碎的操作 都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部

### 轻量级锁

HotSpot虚拟机的对象头分为两部分，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄（Generational GC Age） 等。这部分数据的长度在32位和64位的Java虚拟机中分别会占用32个或64个比特，官方称它为“Mark Word”。这部分是实现轻量级锁和偏向锁的关键。

另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象，还会有一个额外的部分用于存储数组长度

> 例如在32位的HotSpot虚拟机中，对象未被锁定的状态下， Mark Word的32个比特空间里的25个比特将用于存储对象哈希码，4个比特用于存储对象分代年龄，==2 个比特用于存储锁标志位==，还有1个比特固定为0（这表示未进入偏向模式）

虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于==存储锁对象目前的Mark Word的拷贝==

### 常量折叠(暂略...)

### 内存屏障

内存屏障，，是一类同步屏障指令，它使得 ==CPU 或编译器在对内存进行操作的时候, 严格按照一定的顺序来执行,== 也就是说在内存屏障之前的指令和之后的指令不会由于系统优化等原因而导致乱序。

> 在操作系统层面，内存屏障确实是通过特定的CPU指令来实现的

## GC优化

### 经常发生GC？

#### minor GC

**扩容**后，Minor GC时增加了T1（扫描时间），但省去T2（复制对象）的时间，更重要的是对于虚拟机来说，==复制对象的成本要远高于扫描成本==，所以，单次Minor GC时间更多取决于GC后存活对象的数量，而非Eden区的大小。因此如果堆中短期对象很多，那么扩容新生代，单次Minor GC时间不会显著增加。

同时扩容新生代空间后，Minor GC频率降低，对象在新生代得到充分回收，只有生命周期长的对象才进入老年代。这样老年代增速变慢，Major GC频率自然也会降低。

#### CMS

##### 如何避免Major GC时扫描全堆的？

由于新生代对象可能持有对老年代对象的引用（“==跨代引用==”），Remark 阶段不能只以老年代对象为根，否则会误回收仍被新生代引用的老年代对象。为保证正确，<u>Remark 必须扫描整个堆</u>（新生代＋老年代）。

因此可以使用CMSScavengeBeforeRemark参数，用来保证Remark前强制进行一次Minor GC，从而降低Remark阶段的时间

![image-20250413095629955](./4.Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20250413095629955.png)

##### JVM是如何避免Minor GC时扫描全堆的？

==卡表==的具体策略是将老年代的空间分成大小为512B的若干张卡（card）。卡表本身是单字节数组，数组中的每个元素对应着一张卡，当发生老年代引用新生代时，虚拟机将该卡对应的卡表元素设置为适当的值。如上图所示，卡表3被标记为脏（卡表还有另外的作用，标识并发标记阶段哪些块被修改过），之后Minor GC时通过扫描卡表就可以很快的识别哪些卡中存在老年代指向新生代的引用。这样虚拟机通过空间换时间的方式，避免了全堆扫描。

![image-20250413095638129](./4.Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20250413095638129.png)

##### 永久代

1. 通过把-XX:PermSize参数和-XX:MaxPermSize设置成一样，强制虚拟机在启动的时候就把永久代的容量固定下来，==避免运行时自动扩容==。 
2. CMS默认情况下不会回收Perm区，通过参数CMSPermGenSweepingEnabled、CMSClassUnloadingEnabled ，可以让CMS在Perm区容量不足时对其回收。

> 如果服务没有生成大量动态类，回收Perm区收益不大，所以采用方案1，启动时将Perm区大小固定，避免进行动态扩容。

### 堆外内存泄漏

堆外内存（Off‑heap Memory）是指 JVM 堆之外，由本地代码分配的内存区域。堆外内存泄漏 就是指这些本地分配的内存没有被及时释放或归还，JVM 的 GC 无法感知或回收，导致本机内存占用不断上升，最终可能引发 OutOfMemoryError: Direct buffer memory 或者系统层面的内存耗尽。

- 使用 ByteBuffer.allocateDirect() 但没有显式触发清理（Cleaner）
- 通过 sun.misc.Unsafe.allocateMemory() 分配后忘记调用 freeMemory()
- Netty 中 ByteBuf 或 PooledByteBufAllocator 分配后未调用 release()
- JNI 层分配本机内存后未在 ReleaseXXX 或 free()

### 字节码增强/动态调试

https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html

https://tech.meituan.com/2019/11/07/java-dynamic-debugging-technology.html

字节码增强技术相当于是一把打开运行时JVM的钥匙，利用它可以动态地对运行中的程序做修改，也可以跟踪JVM运行中程序的状态。

![image-20250413133940793](./4.Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20250413133940793.png)

如果JVM启动时开启了JPDA，那么类是允许被重新加载的。在这种情况下，已被加载的旧版本类信息可以被卸载，然后重新加载新版本的类

Agent就是JVMTI的一种实现，Agent有两种启动方式，一是随Java进程启动而启动，经常见到的java -agentlib就是这种方式；二是运行时载入，通过attach API，将模块（jar包）动态地Attach到指定进程id的Java进程内。

Attach API 的作用是提供JVM进程间通信的能力，比如说我们为了让另外一个JVM进程把线上服务的线程Dump出来，会运行jstack或jmap的进程，并传递pid的参数，告诉它要对哪个进程进行线程Dump，这就是Attach API做的事情。在下面，我们将通过Attach API的loadAgent()方法，将打包好的Agent jar包动态Attach到目标JVM上

### ZGC

https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html

ZGC也采用==标记-复制==算法，ZGC在==标记、转移和重定位阶段==几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。

ZGC只有三个STW阶段：初始标记，再标记，初始转移

与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。

ZGC通过==着色指针和读屏障==技术，解决了转移过程中准确访问对象的问题，实现了并发转移

在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针

**着色指针**：着色指针是一种将信息存储在指针中的技术。

当应用程序创建对象时，首先在堆空间申请一个虚拟地址，但该虚拟地址并不会映射到真正的物理地址。ZGC同时会为该对象在M0、M1和Remapped地址空间分别申请一个虚拟地址，且这三个虚拟地址对应同一个物理地址，但这三个空间在同一时间有且只有一个空间有效

**读屏障**：读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅**“从堆中读取对象引用”**才会触发这段代码。

```java
Object o = obj.FieldA   // 从堆中读取引用，需要加入屏障
<Load barrier>
Object p = o  // 无需加入屏障，因为不是从堆中读取引用
o.dosomething() // 无需加入屏障，因为不是从堆中读取引用
int i =  obj.FieldB  //无需加入屏障，因为不是对象引用
```

ZGC中读屏障的代码作用：在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。

### JIT

https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html

### Java中9种常见的CMS GC问题分析与解决

https://tech.meituan.com/2020/11/12/java-9-cms-gc.html

场景一：动态扩容引起的空间震荡

场景二：显式 GC 的去与留

场景三：MetaSpace 区 OOM

场景四：过早晋升 *

场景五：CMS Old GC 频繁*

场景六：单次 CMS Old GC 耗时长*

场景七：内存碎片&收集器退化

场景八：堆外内存 OOM

场景九：JNI 引发的 GC 问题

### Sonic热部署

https://tech.meituan.com/2022/03/17/java-hotswap-sonic.html
